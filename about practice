1.前端实现大文件分片上传；地址：https://juejin.cn/post/7053658552472174605?utm_source=gold_browser_extension

// 请求基准地址
axios.defaults.baseURL = 'http://localhost:3000'
// 选中的文件
var file = null
// 选择文件
document.getElementById('fileInput').onchange = function({target: {files}}){
    file = files[0] 
}
// 开始上传
document.getElementById('uploadBtn').onclick = function(){
    if (!file) return;
    // 创建切片   
    // let size = 1024 * 1024 * 10; //10MB 切片大小
    let size = 1024 * 50; //50KB 切片大小
    let fileChunks = [];
    let index = 0 //切片序号
    for(let cur = 0; cur < file.size; cur += size){
        fileChunks.push({
            hash: index++,
            chunk: file.slice(cur, cur + size)
        })
    }
    // 控制并发和断点续传
    const uploadFileChunks = async function(list){
        if(list.length === 0){
            //所有任务完成,合并切片
            await axios({
                method: 'get',
                url: '/merge',
                params: {
                    filename: file.name
                }
            });
            console.log('上传完成')
            return
        }
        let pool = []//并发池
        let max = 3 //最大并发量
        let finish = 0//完成的数量
        let failList = []//失败的列表
        for(let i=0;i<list.length;i++){
            let item = list[i]
            let formData = new FormData()
            formData.append('filename', file.name)
            formData.append('hash', item.hash)
            formData.append('chunk', item.chunk)
            // 上传切片
            let task = axios({
                method: 'post',
                url: '/upload',
                data: formData
            })
            task.then((data)=>{
                //请求结束后将该Promise任务从并发池中移除
                let index = pool.findIndex(t=> t===task)
                pool.splice(index)
            }).catch(()=>{
                failList.push(item)
            }).finally(()=>{
                finish++
                //所有请求都请求完成
                if(finish===list.length){
                    uploadFileChunks(failList)
                }
            })
            pool.push(task)
            if(pool.length === max){
                //每当并发池跑完一个任务，就再塞入一个任务
                await Promise.race(pool)
            }
        }
    }
    uploadFileChunks(fileChunks)

}

2. 滚动加载图片 & do anything else
  原理：元素距离屏幕顶部的高度，小于视窗高度，则判断处于视窗内，显示状态。

  var imgs = document.querySelectorAll('img');
  function isVisible(el) {
    var bound = el.getBoundingClientRect();
    var clientHeight = window.innerHeight;
    return bound.top <= clientHeight;
  }
  function lazyLoad(imgs) {
    for (var i = 0; i < imgs.length; i++) {
      var cur = imgs[i];
      isVisible(cur) && !imgs[i].src && (imgs[i].src = imgs[i].getAttribute('data-src'));
    }
  }
  // 执行一次，在当前滚动位置
  lazyLoad(imgs);
  window.onscroll = function () { 
    lazyLoad(imgs);
  }

3. 模态框展开过渡动画
  @keyframes modalBounceEnter {
    0% {
      opacity: 0;
      transform: scale3d(0.3, 0.3, 0.3);
    }

    20% {
      transform: scale3d(1.1, 1.1, 1.1);
    }

    40% {
      transform: scale3d(1, 1, 1);
    }

    60% {
      opacity: 1;
      transform: scale3d(1.03, 1.03, 1.03);
    }

    100% {
      opacity: 1;
      transform: scale3d(1, 1, 1);
    }
  }

4. 使用content-visibility和content-intrinsic-size控制离屏内容的渲染与否
  content-visibility: visible/hidden/auto;
  content-intrinsic-size: 0 500px; // 控制设置了content-visibility属性的元素未加载时的初始高宽度，不设置浏览器默认为0
  
5. 在持续高频执行动画的元素的父元素上添加will-change属性，作为最后的性能优化手段。建议在完成所有动画后，将元素的will-change删除。
  在样式表中少用will-change
  给will-change足够的时间令其发挥该有的作用
  使用<custom-ident>来针对超特定的变化（如，left, opacity等）
  如果需要的话，可以JavaScript中使用它（添加和删除）
  修改完成后，删除will-change
  不要同时声明太多的属性
  不要应用在太多元素上
  不要把资源浪费在已停止变化的元素上

6. canvas将彩色图片转化为黑白图片：
  let myCanvas = document.getElementById("my-canvas");
    let cxt = myCanvas.getContext("2d");
    const natuImage = new Image();

    /** 图片跨域处理 */
    natuImage.crossOrigin = 'anonymous';
    natuImage.src = "https://cdn-img.ludashi.com/a/202109/03/61319752bb82d.jpg";
    natuImage.onload = (ev) => {
      console.log(ev.path, 'ev.pathev.pathev.pathev.pathev.path');
      let { height, width } = ev.path[0];
      natuImage.width = width;
      natuImage.height = height;
      myCanvas.width = width;
      myCanvas.height = height;
      cxt.drawImage(natuImage, 0, 0);
      let imageData = cxt.getImageData(0, 0, width, height).data;
      console.log(imageData, 'imageDataimageDataimageDataimageData');
      cxt.fillStyle = "#ffffff";
      cxt.fillRect(0, 0, width, height);
      let currentR, currentG, currentB;

      /** 横向像素色彩转化 */
      for (let h = 0; h < height; h += 1) {
        for (let w = 0; w < width; w += 1) {
          let position = (width * h + w) * 4;
          let r = imageData[position], g = imageData[position + 1], b = imageData[position + 2], a = imageData[position + 3];
          if (Math.abs((r + g + b) - (currentR + currentG + currentB)) > 65 || r + g + b < 95) {
            cxt.fillStyle = `rgba(0, 0, 0, 1)`;
            cxt.fillRect(w, h, 1, 1);
          }
          currentR = r;
          currentG = g;
          currentB = b;
        }
      }

      /** 纵向像素色彩转化 */
      for (let w = 0; w < width; w += 1) {
        for (let h = 0; h < height; h += 1) {
          let position = (width * h + w) * 4;
          let r = imageData[position], g = imageData[position + 1], b = imageData[position + 2], a = imageData[position + 3];
          if (Math.abs((r + g + b) - (currentR + currentG + currentB)) > 65 || r + g + b < 95) {
            cxt.fillStyle = `rgba(0, 0, 0, 1)`;
            cxt.fillRect(w, h, 1, 1);
          }
          currentR = r;
          currentG = g;
          currentB = b;
        }
      }
    }

7.canvas处理图片时，跨域问题前端处理：
  1.添加属性(现代浏览器下有效，原理是告知对方出图片外的资源都不要传送过来)：var img = new Image(); img.crossOrigin = 'anonymous';
  2.针对IE10（上述现代浏览器均有效）：
    function loadImg (url) {
      if (!url) return;
      var xhr = new XMLHttpRequest();
      xhr.onload = function () {
          var url = URL.createObjectURL(this.response);
          var img = new Image();
          img.onload = function () {
              // 此时你就可以使用canvas对img为所欲为了
              // ... code ...
              // 图片用完后记得释放内存
              URL.revokeObjectURL(url);
          };
          img.src = url;
      };
      xhr.open('GET', url, true);
      xhr.responseType = 'blob';
      xhr.send();
    }

  /** canvas插入文案定位方法嵌入原型, 用于处理文案动态居中 */
    CanvasRenderingContext2D.prototype.letterSpacingText = function (text, x, y, letterSpacing) {
      var context = this;
      var canvas = context.canvas;
      if (!letterSpacing && canvas) {
        letterSpacing = parseFloat(window.getComputedStyle(canvas).letterSpacing);
      }
      if (!letterSpacing) {
        return this.fillText(text, x, y);
      }
      var arrText = text.split('');
      var align = context.textAlign || 'left';
      // 这里仅考虑水平排列
      var originWidth = context.measureText(text).width;
      // 应用letterSpacing占据宽度
      var actualWidth = originWidth + letterSpacing * (arrText.length - 1);
      // 根据水平对齐方式确定第一个字符的坐标
      if (align == 'center') {
        x = x - actualWidth / 2;
      } else if (align == 'right') {
        x = x - actualWidth;
      }
      // 临时修改为文本左对齐
      context.textAlign = 'left';
      // 开始逐字绘制
      arrText.forEach(function (letter) {
        var letterWidth = context.measureText(letter).width;
        context.fillText(letter, x, y);
        // 确定下一个字符的横坐标
        x = x + letterWidth + letterSpacing;
      });
      // 对齐方式还原
      context.textAlign = align;
    };
  微信H5图片下载，拉起action sheet；需要动态绘制图片的，使用toDataUrl()而不能使用toBlob()，后者下载的图片异常。

  微信H5上下拉动时，页面出现（微信自带的下拉刷新区域和上滑加载更多区域，交互性差，可以为body绑定touchmove事件，并使用e.preventDefault阻止默认事件，规避该现象）