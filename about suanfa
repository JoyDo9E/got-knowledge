1.五大常用算法(分治算法、动态规划算法、贪心算法、回溯法、分治界限法)

2.滑动窗口经典算法解决求解几数之和等于某个固定值，核心思想：
  求n数之和为m，并返回数组项的下标，
  a.先将数组递增排序；
  b.固定前n-2个数字为固定数组项，滑动窗口的两指针a, b去指定另外两值，根据和的情况递归（大于m - sum(n-2)，则b -= 1; 小于m - sum(n-2)， 则 a += 1，直到a >= b）；
  c.循环固定的数组项
  综合时间复杂度为n的n-2次方。
-------------------------------------
  滑动窗口经典算法解决盛最多水的问题，核心思想：
  固定长度（x轴距离）最大，递增变化宽度（y轴高度）,只有高度增加才有可能在长度变小的情况下保持面积变大的可能；利用滑动窗口双指针。

  // 盛更多水的容器
  var a = [[5, 6], [2, 9], [9, 2], [9, 3], [1, 6], [3, 2], [8, 2], [7, 1]];
  function findMore (arr) {
      if (!Array.isArray(arr) || arr.length < 2) return 0;
      // x轴从小到大排序
      var sorted = a.sort((a, b) => a[0] - b[0]);
      console.log(sorted, 'sorted');
      var resArr = [];
      function recur (left, right) {
          if (left >= right) return;
          var isRightLess = sorted[left][1] > sorted[right][1]
          var lessVal = isRightLess ? sorted[right][1] : sorted[left][1];
          var lessIdx = isRightLess ? right : left;
          console.log(`left:${left},right:${right},面积:${(sorted[right][0] - sorted[left][0]) * lessVal}`);
          resArr.push((sorted[right][0] - sorted[left][0]) * lessVal);
          // 变化高度小的值，递增（只有高度增加才有可能在长度变小的情况下保持面积变大的可能）
          recur(isRightLess ? left : (left + 1), isRightLess ? (right-1) : right)
      }
      // 初始指针指向有序数组的开头 & 结尾
      recur(0, sorted.length - 1);
      return Math.max.apply(null, resArr);
  }
--------------------------------------
  快慢指针可用于解决以下问题：
  https://github.com/ascoders/weekly/blob/master/%E7%AE%97%E6%B3%95/199.%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%AE%97%E6%B3%95%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%8B.md
    1.判断链表是否为循环链表；
      fast指针移动速度是slow指针的2倍，判断在某一周期内是否能 list[fast] === list[slow]
    2.判断链表的中点；
      fast指针移动速度是slow指针的2倍，fast到达终点时，slow所指即为中点
    3.原地删除数组中重复项，返回删除后的数组长度；

常见排序方法：
// 冒泡排序
function maopao (arr) {
    if (!Array.isArray(arr))return [];
    const len = arr.length;
    for (var i=0;i<len;i++) {
        for(var j=i+1;j<len;j++){
            if (arr[i] > arr[j]) {
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}

// 快速排序
function quick (arr) {
    if (!Array.isArray(arr)) return [];
    var len = arr.length;
    if (len <= 1) return arr;
    var pivotIndex = Math.ceil(len / 2), pivot = arr[pivotIndex], left = [], right = [];
    arr.splice(pivotIndex, 1);
    for (var i=0;i<len - 1; i++) {
        arr[i] <= pivot ? left.push(arr[i]) : right.push(arr[i]);
    }
    // console.log(left, 'left');
    // console.log(right, 'right');
    return [...quick(left), pivot, ...quick(right)];
}

// 选择排序
function selectSort (arr) {
    if (!Array.isArray(arr))return [];
    var len = arr.length;
    for (var i=0;i<len;i++){
        var minIdx = i;
        for (var j=i+1;j<len;j++){
            if (arr[minIdx] > arr[j]) {
                minIdx = j;
            }
        }
        var temp = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = temp;
    }
    return arr;
}


// 插入排序（O(n) - O(n2)）
function insertSort (arr) {
    if (!Array.isArray(arr)) return [];
    var len = arr.length, pre, cur;
    for (var i=1;i<len;i++) {
        pre = i - 1;
        cur = arr[i];
        while (pre >= 0 && arr[pre] >= cur) {
            arr[pre + 1] = arr[pre];
            pre--;
        }
        arr[pre + 1] = cur;
    }
    return arr;
}

// 滑动窗口解决最长字串问题
var lengthOfLongestSubstring = function(s) {
    const len = s?.length;
    if (!len) return 0;
    const resMap = new Map();
    const resArr = [];
    for (let i=0; i< len; i++) {
        resMap.set(s[i], s[i]);
        for (let j=i+1; j<len; j++) {
            if (resMap.has(s[j])) break;
            resMap.set(s[j], s[j]);
        }
        resArr.push(resMap.size);
        resMap.clear();
    }
    return Math.max.apply(null, resArr);
};
lengthOfLongestSubstring('abcabcbb'); // 3
lengthOfLongestSubstring(' '); // 1
lengthOfLongestSubstring('pwwkew'); // 3

  