1. 滚动加载图片 & do anything else
  原理：元素距离屏幕顶部的高度，小于视窗高度，则判断处于视窗内，显示状态。

  var imgs = document.querySelectorAll('img');
  function isVisible(el) {
    var bound = el.getBoundingClientRect();
    var clientHeight = window.innerHeight;
    return bound.top <= clientHeight;
  }
  function lazyLoad(imgs) {
    for (var i = 0; i < imgs.length; i++) {
      var cur = imgs[i];
      isVisible(cur) && !imgs[i].src && (imgs[i].src = imgs[i].getAttribute('data-src'));
    }
  }
  // 执行一次，在当前滚动位置
  lazyLoad(imgs);
  window.onscroll = function () { 
    lazyLoad(imgs);
  }

2. 模态框展开过渡动画
  @keyframes modalBounceEnter {
    0% {
      opacity: 0;
      transform: scale3d(0.3, 0.3, 0.3);
    }

    20% {
      transform: scale3d(1.1, 1.1, 1.1);
    }

    40% {
      transform: scale3d(1, 1, 1);
    }

    60% {
      opacity: 1;
      transform: scale3d(1.03, 1.03, 1.03);
    }

    100% {
      opacity: 1;
      transform: scale3d(1, 1, 1);
    }
  }

3. 使用content-visibility和content-intrinsic-size控制离屏内容的渲染与否
  content-visibility: visible/hidden/auto;
  content-intrinsic-size: 0 500px; // 控制设置了content-visibility属性的元素未加载时的初始高宽度，不设置浏览器默认为0
  
4. 在持续高频执行动画的元素的父元素上添加will-change属性，作为最后的性能优化手段。建议在完成所有动画后，将元素的will-change删除。
  在样式表中少用will-change
  给will-change足够的时间令其发挥该有的作用
  使用<custom-ident>来针对超特定的变化（如，left, opacity等）
  如果需要的话，可以JavaScript中使用它（添加和删除）
  修改完成后，删除will-change
  不要同时声明太多的属性
  不要应用在太多元素上
  不要把资源浪费在已停止变化的元素上

5. canvas将彩色图片转化为黑白图片：
  let myCanvas = document.getElementById("my-canvas");
    let cxt = myCanvas.getContext("2d");
    const natuImage = new Image();

    /** 图片跨域处理 */
    natuImage.crossOrigin = 'anonymous';
    natuImage.src = "https://cdn-img.ludashi.com/a/202109/03/61319752bb82d.jpg";
    natuImage.onload = (ev) => {
      console.log(ev.path, 'ev.pathev.pathev.pathev.pathev.path');
      let { height, width } = ev.path[0];
      natuImage.width = width;
      natuImage.height = height;
      myCanvas.width = width;
      myCanvas.height = height;
      cxt.drawImage(natuImage, 0, 0);
      let imageData = cxt.getImageData(0, 0, width, height).data;
      console.log(imageData, 'imageDataimageDataimageDataimageData');
      cxt.fillStyle = "#ffffff";
      cxt.fillRect(0, 0, width, height);
      let currentR, currentG, currentB;

      /** 横向像素色彩转化 */
      for (let h = 0; h < height; h += 1) {
        for (let w = 0; w < width; w += 1) {
          let position = (width * h + w) * 4;
          let r = imageData[position], g = imageData[position + 1], b = imageData[position + 2], a = imageData[position + 3];
          if (Math.abs((r + g + b) - (currentR + currentG + currentB)) > 65 || r + g + b < 95) {
            cxt.fillStyle = `rgba(0, 0, 0, 1)`;
            cxt.fillRect(w, h, 1, 1);
          }
          currentR = r;
          currentG = g;
          currentB = b;
        }
      }

      /** 纵向像素色彩转化 */
      for (let w = 0; w < width; w += 1) {
        for (let h = 0; h < height; h += 1) {
          let position = (width * h + w) * 4;
          let r = imageData[position], g = imageData[position + 1], b = imageData[position + 2], a = imageData[position + 3];
          if (Math.abs((r + g + b) - (currentR + currentG + currentB)) > 65 || r + g + b < 95) {
            cxt.fillStyle = `rgba(0, 0, 0, 1)`;
            cxt.fillRect(w, h, 1, 1);
          }
          currentR = r;
          currentG = g;
          currentB = b;
        }
      }
    }

  6.canvas处理图片时，跨域问题前端处理：
    1.添加属性(现代浏览器下有效，原理是告知对方出图片外的资源都不要传送过来)：var img = new Image(); img.crossOrigin = 'anonymous';
    2.针对IE10（上述现代浏览器均有效）：
      function loadImg (url) {
        if (!url) return;
        var xhr = new XMLHttpRequest();
        xhr.onload = function () {
            var url = URL.createObjectURL(this.response);
            var img = new Image();
            img.onload = function () {
                // 此时你就可以使用canvas对img为所欲为了
                // ... code ...
                // 图片用完后记得释放内存
                URL.revokeObjectURL(url);
            };
            img.src = url;
        };
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';
        xhr.send();
      }