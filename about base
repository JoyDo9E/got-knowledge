1.浏览器（非合并，优化状态下），每一个tab页即为一个进程，每个进程又包含以下线程：
    1.GUI渲染进程；
    2.js引擎线程（与GUI渲染进程互斥，即加载js时，页面会停止渲染）；
    3.事件触发线程；
    4.定时器触发线程（setTimeout,setInterval）；
    5.异步请求线程
2.项目中的worker系列：
    web worker:
        创建javascript多线程，在主线程运行的同时，web worker在后台运行，互不干扰；
        到完成计算任务后，将结果返回主线程（适用于计算密集型、高延迟任务）；
        一旦新建成功，始终运行，耗费资源；
        受到以下限制：
            1.同源：worker运行脚本需与主线程脚本同源；
            2.DOM：无法获取DOM对象（document、window、parent...）可访问（navigator，location）；
            3.通信：只能通过消息机制与主线程通信；
                主线程：
                    var worker = new Worker('来源于网络的脚本');
                    worker.postMessage('hello worker');
                worker:
                    var worker = new Worker('来源于网络的脚本');
                    worker.onmessage = function (e) {...};

            4.脚本：无法使用alert和confirm但可以使用ajax
            5.文件：无法读取本地文件
    service workers: (相当于本地mock一样，会在无网络环境下，阻塞请求，返回缓存数据)

        主线程中：
            navigator.serviceWorker.register('/service-worker.js');
        worker中:
            /* service-worker.js */

            // Install （安装）
            self.addEventListener('install', function(event) {
                // ...
            });

            // Activate （激活）
            self.addEventListener('activate', function(event) {
                // ...
            });

            // 监听主文档中的网络请求
            self.addEventListener('fetch', function(event) {
                // ...
            });

3.class:
    (1).静态公共方法, static: 调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法。静态方法通常用于为一个应用程序创建工具函数。
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            static distance(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.hypot(dx, dy);
            }
        }
        const p1 = new Point(5, 5);
        const p2 = new Point(10, 10);
        console.log(Point.distance(p1, p2));
    (2).静态公有字段：创建一个只在每个类里面只存在一份，而不会存在于你创建的每个类的实例中的属性
        class ClassWithStaticField {
            static staticField = 'super';
            static moreStaticField = this.staticField + 'more';    // 同一类中，可通过this["公有字段名"]访问公有字段
            static staticFn () { console.log('staticFn'); return 'super'; }
        }
        class SubClassWithStaticField extends ClassWithStaticField {
            static subStaticField = 'sub';
            console.log(super);                       //  "super"是指向父类的指针
            static superData = super.staticFn();      //  继承父类的子类，可通过super['父类中的静态公有方法名']访问父类中的静态公有方法
        }
        const sub = new SubClassWithStaticField();
        sub.subStaticField // "undefined"
        SubClassWithStaticField.subStaticField // 'sub'
        SubClassWithStaticField.staticField // 'super' 
        特性：实例不可访问，只存在于类；可通过继承链（原型链）访问父类静态公有字段
    (3).公共实例方法 & 公共字段：
        class ClassWithInstanceField {
            instanceField = 'instance field';
        }
        与静态共有字段 & 静态方法的区别在于，实例是否可访问
    (4).成员方法，只能被实例调用，以及子实例调用，不能被构造函数或者类直接调用
        class Person {
            arr: [1, 2], // 引用类型的值每个实例单独clone一份，互不影响
            sayTime () {console.log(Date.now())},
            constructor (name, age) {
                this.name = name;
                this.age = age;
            }
        }
        var peter = new Person('peter', 27);
        peter.arr // [1, 2]
        class WhiteMan extends Person {
            constructor (name, age) {
                super(name, age) // 必须运行super，子类本身无this，需运行super继承超类的this
            }
        }
        var tom = new WhiteMan('tom', 25);
        tom.arr // [1, 2]
        tom.arr.push(3);
        tom.arr // [1, 2, 3]
        peter.arr // [1, 2]


4.IE9及以下版本，XMLHttpRequest 不支持跨域请求，XDomainRequest 虽然支持跨域，却又不支持 cookie 传递  // IE9以下请求需要使用jsonp否则ajax只会执行error回调
5.babel转义原理：
    (1).babelon.parse方法将js的词法、语法解析成为AST（抽象语法树：https://astexplorer.net/）;
    (2).babel-traverse（主要用于插件中）或者babel-generator,结合babel-core(babel转译API)将AST抽象语法树编译为js代码;
  插件介绍：
    babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装
    babel-runtime：功能类似babel-polyfill，一般用于library或plugin中，因为它不会污染全局作用域
---------------------------------------------------------------------------------------------------
    es20xx的preset只转译该年份批准的标准，而env则代指最新的标准，包括了latest和es20xx各年份
    另外，还有 stage-0到stage-4的标准成形之前的各个阶段，这些都是实验版的preset，建议不要使用。
6.ts全局变量声明，当一个文件没有使用模块，即没有使用es6的export等关键字，那么文件内所有的定义都是全局的；通常在.d.ts文件中定义全局变量类型：
    // global.d.ts
    1.声明全局变量
        declare const name: string
    2.声明全局库
        declare module Foo {
            export default x
        }
7.ts提供了Number, Boolean, Array, String, Null, Undefined, Never, Tuple(元组，每个位置类型固定的数组), Enum(枚举类型), Any, Void, Object.
8.通过new关键字实例化一个构造函数，会将构造函数的this设置成为一个全新的空对象
    function Foo () {
        console.log(this.bar);
    }
    var bar = 'bar';
    Foo(); // 'bar'
    new Foo(); // undefined
9.ES6语法和新增特性转化为ES5：polyfilling & (transpeling【转换】 + compiling【编译】) 括号内内容主要针对语法转义或新增的api，如const、flat等；

10.考虑如下：
    /** let关键字 */
    for (let i=0; i<10; i++){
        setTimeout(function () {console.log(i);}, i*1000);
    }
    /** var关键字 */
    for (var i=0; i<10; i++){
        setTimeout(function () {console.log(i);}, i*1000);
    }
    for 循环头部的 let i 不只为 for 循环本身声明了一个 i，而是为循环的每一次迭代都重新声明了一个新的 i。这意味着 loop 迭代内部创建的闭包封闭的是每次迭代中的变量，就像期望的那样。
    var关键字的情况下，相当于外层作用域只有一个i，这个i被闭包封闭进去，而不是每一层循环都有一个全新的i。

11.for...of的等价代码
    var a = ["a","b","c","d","e"]; 
    for (var i of a) {
        console.log(i);
    }
    
    ==>

    for (var val, ret, it = a[Symbol.iterator](); 
        (ret = it.next()) && !ret.done; 
    ) { 
        val = ret.value; 
        console.log( val ); 
    }

12. 图片保留宽高比，且自动填充满父元素：
    object-fit: cover;
    另外还可设置图片在父元素中的位置，类似于background-position属性：
    object-position: 50% 100%;

13. 滚动过程中，每次停留都会侦测是否处于子元素的中部，若不是则自动滚动补足
    父元素：
        overflow: auto;
        scroll-snap-type: x mandatory;
    子元素：
        scroll-sanp-align: center; // 保持滚动停留在子元素中部

14.可以使用window.requestIdleCallback在系统空闲期间，调用事件循环遍历或者低优先级的函数。
   使用window.cancelIdleCallback取消绑定，结束回调
    -------
    navigator.scheduling.isInputPending([eventNameArray, eg: 'mousedown', 'mouseup'])
    通过合理使用 isInputPending 方法，我们可以在页面渲染的时候及时响应用户输入，
    并且，当有长耗时的JS任务要执行时，可以通过 isInputPending 来中断JS的执行，将控制权交还给浏览器来执行用户响应。

15.函数柯里化：使函数从一次调用传入多个参数变成多次调用每次传一个参数。
  function curry(fn) {
    let judge = (...args) => {
        if (args.length == fn.length) return fn(...args)
        return (...arg) => judge(...args, ...arg)
    }
    return judge
  }
  eg:
    function add(a, b, c) {
      return a + b + c
    }
    add(1, 2, 3)
    let addCurry = curry(add)
    addCurry(1)(2)(3)

16.改变常规函数（非箭头函数）的this指向
  (0, Obj.fn)()  等价于  Obj.fn.call(undefined)
  (0, Obj.fn)(Scoped)  等价于  Obj.fn.call(Scoped)

17.js数组在内存中存储形式：
  (1).同类型的数据分配一个连续的内存空间，如Array<number>
  (2).存在非同类型的数据的数组使用hash映射分配内存空间 ---  <数据结构，hash表地址冲突时解决方法？>

18.CSS 命令 font-variant-east-asian: traditional;，可以让网站字体从简体变成繁体。

19.可能嵌入跨源的资源包括：
  <script src='***' />
  <link href='*' />
  <img src='*' />
  <video> <audio> <object>

20.缓存：强缓存 & 协商缓存
  强缓存： 
    Expires(http 1.0): 为服务端返回的数据到期时间（绝对时间）。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。<现已使用cache-control替代>
    cache-control(http 1.1): max-age（单位s） / must-revalidate / no-cache / no-store / public / private

    服务端配置强缓存生效（cache-control: 'max-age: 30'以及其过期时间）才会生效。客户端能设置强缓存失效（cache-control: no-store / no-cache mas-age=0）时有用。

  协商缓存：
    last-modified & last-modified-since 
      如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
      如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。
    
    Etag（服务端文件生成的hash值） & If-None-Match
    

21.css触发GPU硬件加速的方式，transform, filter, opacity;
   操作动画时，最好使用transform & 3d属性：相较于2d属性，3d属性在页面渲染前就会创建出独立的符合图层，用以展示执行动画；而2d在动画开始前才会创建符合图层，这样会触发两次页面的重绘（创建 & 删除）；
   translate3d 和 translateZ开启GPU硬件加速后可能会导致浏览器频繁闪烁或抖动，解决方法：
      -webkit-backface-visibility: hidden;
      -webkit-perspective: 1000;
  
22.流量单位转化js原生写法
  // nBytes表示总的size大小，单位kb
  let sOutput = nBytes + " bytes";
  const aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
  for (nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
    sOutput = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + nBytes + " bytes)";
  }

23.class本质也是function，class是function的语法糖
  class Person {}; typeof Person === 'function' // true

24.ES5函数式类写法与ES6的class类写法除写法之外的区别：
  (1).函数式赋值会提升并赋值，但class式只会提升不会赋值（类似于let & const赋值词）；
    var foo = new Foo('pt'); // ok!
    function Foo(name) {this.name = name}
    -------
    var foo = new Foo('pt') // error!
    class Foo {
      constructor(name) {
        this.name = name;
      }
    }
  (2).class内部会启动严格模式；
  (3).class的所有方法，包括静态方法和原型方法都是不可枚举的，而函数式相反
    function Foo () {sayName () {console.log(1)}, sayHi () {console.log('hi')}}
    console.log(Object.keys(Foo).length) // 2
  (4).class中的方法无法，无prototype，无[[constructor]]，无法被实例化，即new；
  (5).class必须用new才能实例化
  (6).class内部无法重写类名

25.浏览器事件循环机制：
  宏任务： setTimeout / setInterval / setImmidiate / I/O(浏览器中操作indexDB) / UI render
  微任务： process.nextTick / promise（async & await） / Object.observe（已废弃） / MutationObserver(DOM树更改监听)
  (1).一个event loop可能存在一个或多个task（宏任务）队列，但只存在一个microtask（微任务）队列;
  (2).脚本刚开始执行时，整体是一个宏任务队列的首项，压入执行，分解其中的宏任务和微任务。
  (3).主线程中读取到事件回调处理线程时，会将其挂起在webapis中，当其被调用时，再将其回调压入宏任务队列中；
  (4).异步请求线程执行异步请求返回数据后，（常规操作会使用promise即微任务接收反馈数据并处理，相当于异步请求这个宏任务执行逻辑中压入了一个微任务
      执行相关回调（宏任务）；
  (5).await之后的逻辑相当于放在promise.then中执行的逻辑，会压入微任务队列，即使await等待执行的是个同步逻辑。
  (6).new Promise((resolve, reject) => {...//resolve & reject之前的逻辑都属于同步逻辑，在第一次执行时就会处理这部分逻辑})

  完整流程：
    脚本整体作为一个宏任务，压入执行栈，开始执行；运行过程中，发现微任务，压入microtask队列；继续执行当前宏任务；发现宏任务，压入macrotask队列；
    当前宏任务执行完毕后，立即执行microtask栈中的微任务，微任务栈清空完毕后。循环。

26. nodejs事件循环机制
  ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘

   外部输入数据 --> 轮询阶段（poll） --> 检查阶段(check) --> 关闭事件回调阶段(close callback) --> 定时器检查阶段(timer) --> I/O 事件回调阶段(I/O callbacks) --> 闲置阶段(idle, prepare) --> 轮询阶段...
  这些阶段大致的功能如下：
  定时器检测阶段(timers): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
  I/O事件回调阶段(I/O callbacks): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
  闲置阶段(idle, prepare): 这个阶段仅在内部使用，可以不必理会
  轮询阶段(poll): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
  检查阶段(check): setImmediate()的回调会在这个阶段执行。
  关闭事件回调阶段(close callbacks): 例如socket.on('close', ...)这种close事件的回调
  poll：
  这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。
  这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。
  check:
  该阶段执行setImmediate()的回调函数。

  close:
  该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

  timer阶段:
  这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。

  I/O callback阶段：
  除了以下的回调函数，其他都在这个阶段执行：

  setTimeout()和setInterval()的回调函数
  setImmediate()的回调函数
  用于关闭请求的回调函数，比如socket.on('close', ...)

27. 正则表达式：/(\d{4})([-/.])\d{2}\2\d{2}/ 能匹配 "2017-06-12" 和 "2017.06.12"，不能匹配 "2017-06.12";
  表达式中的“\2”表示模拟第二个中括号匹配的内容（[-/.]），即前面匹配了什么后面也匹配什么，类似于泛型。


28.手写throttle函数：【https://github.com/mqyqingfeng/Blog/issues/26】
  1. 时间戳方式（简易版）：
    const throttle = (fn, delay) => {
      let args, context, previous = 0;
      return function () {
        const now = +new Date();
        args = arguments;
        context = this;
        if (now - previous > delay) {
          fn.call(context, args);
          previous = now;
        }
      }
    }

29.webpack中loader相关：
    @babel/parser：将源代码转化为AST；file.readFile('path', 'utf-8', (err, data) => { // data});
    @babel/travarse：遍历生成的AST节点树，并可替换，删除，添加节点；
    @babel/generator：AST => 代码 & sourcemap
    @babel/types：提供各种各样针对AST节点树的工具函数集，构建、校验、转换AST节点, eg:
      const parser = require('@babel/parser');
      const t = require('@babel/types');
      const traverse = require('@babel/traverse').default;

      let code = 'function a() {}';
      const ast = parser.parse(code);
      traverse(ast, {
        FunctionDeclaration(path) {
          const node = path.node;
          // 获取函数名称等
          path.replaceWith();//替换为新的节点
          path.remove(); // 删除当前节点
          path.skip(); //跳过子节点(跳过子树遍历)
          let copyNode = t.cloneNode(node);//复制当前节点
          traverse(copyNode, {}, {}, path);// 对子树进行遍历和替换，不影响当前的path
        }
      });

30.weakmap使用场景：
  1).数据缓存；比如：
    var p = document.getElementsByTagname('p'), wm = new WeakMap();
    wm.set(p, 'this is p's inner text');
    // 当手动垃圾回收p时，弱引用保存的数据也同时被删除
    p = null;
  2).私有化属性。

31.defineProperty和proxy的使用区别：
  proxy定义了多种数据存取属性方法，出了与defineProperty共有的getter和setter外，还有很多，见https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
  当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即Proxy的实例才可以触发拦截;

32.惰性函数，就是基于闭包会缓存外作用域的数据的原理，解决多次重复执行幂等逻辑的问题，如定义foo函数并使其只执行一次判断且返回第一次执行的date：
  function foo () {
    let d = new Date();
    /** 下次执行foo就执行新定义的foo函数，而新定义的foo函数中闭包缓存了第一次定义的date数据 */
    foo = function () {
      return d;
    }
    return foo();
  }
  另外，原生js浏览器兼容性处理时，（多次重复判断，结果幂等）也可使用惰性函数（缓存判断结果，避免重复判断）

33.使用window.matchMedia('screen and (max-width: 999px)')来在js中使用媒体查询；
   使用animation.fn在js中执行动画（既@keyframes **{}），详见https://developer.mozilla.org/zh-CN/docs/Web/API/Animation/effect

34.class Demo { 
    method () { 
      // ...
    }
    method1 = function () {
      // ...
    }
    method2 = () => {
      // ...
    }
  },
  method方法为对象的原型方法；method1和method2均为对象的实例方法；
  1).对象字面量的this类型为该对象字面量本身（本身推导出来的类型）
    let foo = {
      x: 'name',
      f(n: number) {
        console.log(this); // this: {x: string; (n: number) => void}
      }
    }
  2).标注了对象字面量的类型，则this的类型等于标注的类型
    interface Foo {
      name: string;
      f: (n: number) => void
    }
    let foo: Foo = {
      f (a) {
        console.log(this); // this: Foo
      }
    }
  3).如果对象字面量的方法标注了this的类型，则为标注的类型
    let foo = {
      f (this: { msg: string }) {
        console.log(this); // this: { msg: string }
      }
    }
  4).如果对象字面量进行了类型标注，且类型标注包含了ThisType[只有在--noImplicitThis配置了之后才会生效]，则this类型为ThisType的类型
    type Foo = {
      name: string;
      age: number;
      say: () => void;
    } & ThisType<{ msg: boolean }>

    let foo: Foo = {
      name: '1',
      age: 12,
      // 箭头函数不适用，其this指向globalThis
      say: function () {
        console.log(this)
      }
    }