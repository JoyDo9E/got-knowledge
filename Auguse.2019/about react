一些关于react-router-dom的使用以及documentation相关点：
    1.关于使用：
        （1）.以数组形式引入各个route，每个route项包含该路由的相关配置，如：path(路径)、exact（是否精确匹配）、subRoutes（包含的子路由）等信息；
        （2）.自定义组件，结合React-router-dom的Route组件，遍历获取的路由数组，生成便返回路由virtual node；
        （3）.在root node（app.js）中引入该路由组件，达到引入各个组件的目的；

        // 第一步
        export default [
          {
            path: '/',
            exact: true,
            component: Loadable({
              loader: () => import('@/pages/login/login'),
              loading: RouterLoading,
            }),
          },
          {
            path: '/admin',
            // component: admin,
            component: Loadable({
              loader: () => import('@/pages/admin'),
              loading: RouterLoading,
            }),
            subRoutes: [
              {
                path: '/admin/realm',
                exact: true,
                component: Loadable({
                  loader: () => import('@/pages/admin/realm/realm'),
                  loading: RouterLoading,
                }),
              }
            ]
          }
        ]

        // 第二步
        import React from 'react';
        import { Route } from 'react-router-dom';

        export default class RouteWithSubRouters extends React.Component {
          render() {
            const route = this.props;
            return (
              <Route
                path={route.path}
                exact={!!route.exact}
                render={props => (
                  <route.component {...props} subRoutes={route.subRoutes} />
                )}
              />
            );
          }
        }

        // 第三步
        import React from 'react';
        import { Switch } from 'react-router-dom';
        import RouteWithSubRouters from './RouteWithSubRouters';
        import routers from '@/routers';

        export default class App extends React.Component {
          render() {
            return (
              <React.Fragment>
                <Switch>
                  {routers.map((route, index) => {
                    return <RouteWithSubRouters key={index} {...route} />;
                  })}
                </Switch>
              </React.Fragment>
            );
          }
        }

react-router-dom 6.0升级内容：
  1.<Switch>变更为<Routes>
      // v5
      <Switch>
          <Route exact path="/"><Home /></Route>
          <Route path="/profile"><Profile /></Route>
      </Switch>

      // v6
      <Routes>
          <Route path="/" element={<Home />} />
          <Route path="profile/*" element={<Profile />} />
      </Routes>
  2.<Route>的属性变更
    原来的<Route component={} render={} /> 变更(统一)为 <Route element={} />，更方便简洁的使用嵌套路由
  3.嵌套路由变得简单
    <Route children />变更为可接受子路由；
    匹配规则更简单，<Route exact /> <Route strict />;
    路径层次更清晰；
  4.hook变化：useHistory变更为useNavigate
    // v5
    history.push('/home');
    history.replace('/home');

    // v6
    navigate('/home');
    navigate('/home', {replace: true});

  5.hook变化：useRoutes代替react-router-config
    function App() {
      let element = useRoutes([
        { path: '/', element: <Home /> },
        { path: 'dashboard', element: <Dashboard /> },
        { path: 'invoices',
          element: <Invoices />,
          children: [
            { path: ':id', element: <Invoice /> },
            { path: 'sent', element: <SentInvoices /> }
          ]
        },
        // 重定向
        { path: 'home', redirectTo: '/' },
        // 404找不到
        { path: '*', element: <NotFound /> }
      ]);
      return element;
    }
  6.新标签<Outlet />，相当于vue的<router-view />，或者react的{this.props.children}，用于嵌套路由中次级路由嵌套展示子路由使用；
  7.可同时使用多个<Routes />，
  8.将<NavLink exact>替换为<NavLink end>；NavLink用于路由匹配时，导航样式的添加与删除；
  9.将useRouteMatch替换为useMatch。用以判断当前是否匹配某一路由。
    import { useMatch } from 'react-router-dom';
    const isMatch = useMath('/post/:id');

------------------------------------------------------------------
  a. hooks中更新状态数据后，组件重新渲染；它不是神奇的“data binding”, “watcher”, “proxy”，或者其他任何东西。仅仅是一个单纯的数据变更，一次快照。
  函数组件会去调用这个更新后的状态数据；从而更新组件;
  b. 当setState遇上计时器时，会缓存触发计时器时的数据，压入宏任务，待计时结束执行回调函数。【https://codesandbox.io/s/w2wxl3yo0l】;
  c. React会记住你提供的effect函数，并且会在每次更改作用于DOM并让浏览器重绘之后去调用useEffect函数（传参为当时的数据）;
    function Counter() {
      const [count, setCount] = useState(0);
      // useEffect不写依赖项[]意味着每次组件都会执行。
      useEffect(() => {
        setTimeout(() => {
          console.log(`You clicked ${count} times`);
        }, 3000);
      });

      return (
        <div>
          <p>You clicked {count} times</p>
          <button onClick={() => setCount(count + 1)}>
            Click me
          </button>
        </div>
      );
    }
    // 依次打印：
      You clicked 1 times
      You clicked 2 times
      You clicked 3 times
      You clicked 4 times
      You clicked 5 times
  d. 类式组件的this.state.**总是指向一个最新的**值（一个值，每次渲染动态更新它的值），而不是属于某次渲染特定的值；函数式组件的useState的state指向
    一个某次渲染特定的值（fiber的hook中维护了一个immutable的当前数据，每次按压入顺序调用队列中存储的hook函数，修改数据后，传给函数组件，得到最新值）
  e. 每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state。
  f. 在组件内什么时候去读取props或者state是无关紧要的。因为它们不会改变。在单次渲染的范围内，props和state始终保持不变。
  g. 读取未来的props和state【逆潮而动】
    function App() {
      const [count, setCount] = useState(0);
      const latestCount = useRef(count);
      /** 每次count更新都会重新执行函数组件以及其useEffect闭包函数；latestCount.current每次
        都会得到最新的count快照值，当定时器结束时，读取到最新的count */
      useEffect(() => {
        // Set the mutable latest value
        latestCount.current = count;
        setTimeout(() => {
          // Read the mutable latest value
          console.log(`You clicked ${latestCount.current} times`);
        }, 3000);
      });

      return (
        <div>
          <p>You clicked {count} times</p>
          <button onClick={() => setCount(count + 1)}>
            Click me
          </button>
        </div>
      );
    }
  h. 上一次的effect会在重新渲染后被清除，即useEffect中的返回函数，会在下次更新渲染完成后执行，然后再执行本次更新的effect：
    渲染本次UI更新 -> 上一次更新的effect返回函数（清除函数）（捕捉【缓存】了上一轮渲染的props和state） -> 本次更新的effect函数
  i. React只会在绘制后运行effects，组件内的每一个函数（包括事件处理函数，effects，定时器或者API调用等等），会捕捉定义它们的那次渲染中的props和state
  j. useEffect能够根据props和state同步React Tree之外的东西；
------------------------------------------------------------------

React17开始，react 自定义babel的两种方式
--
  npm update @babel/core @babel/plugin-transform-react-jsx
  或 yarn upgrade @babel/core @babel/plugin-transform-react-jsx
--
  npm update @babel/core @babel/preset-react
  或 yarn upgrade @babel/core @babel/preset-react
  



拓展create-react-app创建的项目的webpack配置项方法：   https://blog.csdn.net/qq_22889599/article/details/79507721

react-router-dom 包含 Link Route Switch BrowserRouter：（详细参见react-router-dom官方文档：https://reacttraining.com/react-router/web/api/Route/component）

    BrowserRouter 即Router，路由总组件，用以装载单个Route以及Switch；
    Route 路由组件，负责将各个组件引入并渲染成路由组件；包含三大props：location、history、match；match又包含params、exact(是否精准匹配，即是否会连带渲染上级组件)、path、url这些属性；
            <Route extra=true/false path="/current/path" render={(props) => {}} component={anyComponent}>
        可以通过render函数（方便的在线渲染和包装）或者component传入组件
    Switch 只渲染第一个匹配到的<路由组件>或<重定向组件>。


render阶段： 渲染阶段：生成一颗虚拟dom树；           异常捕获：static getDerivedStateFromError(err){}
commit阶段： 提交阶段：虚拟dom树替换成真实的dom树    异常捕获：ComponentDidCatch(error, info){}

----------------------------

React致力于践行“构建快速响应的大型web程序”，
  亟待解决的问题就是CPU的瓶颈（特定页面更新频率下，组件更新不及时或过快导致的页面卡顿）和IO的瓶颈（请求时延过高）；
  实际处理方式：将同步的更新变更为异步的可中断（浏览器时间分片用尽或有更高优任务插队）的更新。

React 15 至 16: 解决每次状态更新组件都遍历迭代以及不可中断的问题；
  1).在Reconciler & Renderer架构基础上，新增Scheduler（调度器）（即功能更为完备的RequestIdleCallback polyfill），决定哪些任务优先进入Reconciler；
  2).Reconciler中加入shouldYeild（是否需要让步给浏览器主进程执行渲染）判断当前是否有剩余时间

React 16起，任务执行可中断和继续，以保证js执行不阻塞页面渲染，造成页面卡顿（突破CPU更新频率可能带来的页面卡顿问题，实现保持页面响应）：

  Concurrent module: Scheduler(调度器，高优先级任务优先进入Reconciler)  +  Reconciler(协调器，找出变化)(render & fiber & diff)  +  Renderer（渲染器，渲染diff）（dom render / react-native render / test render / act render）
  任务优先级划分一共有5种：
    ImmediatePrority（高优先级任务） / UserBlockingPriority（用户行为阻塞任务） / NormalPriority（平常任务，默认） / LowPriority（低优先级任务） / IdlePriority（闲时任务）
  React根据不同优先级，给予任务expirationTime，优先级越高，expirationTime越快到来：eg：ImmediatePrority的expirationTime = -1；
  scheduler（调度器，独立于react）直接调用并执行taskQueue（根据expirationTime生成的小顶堆）中第一个（即为当前最高优先级的）任务；将其传入Reconciler

  react中组建的渲染分为两个阶段：
    1.render阶段：可被react中断，一旦中断，则废弃；重新渲染时，重复执行之前废弃的部分（是对应变化被整理到current Fiber的过程吗？）
  --------------分界点为render函数----------------
    2.commit阶段：不能被中断（是对应渲染current Fiber为真实DOM并同步到workinprogress Fiber的过程吗？）

  -----------------------------------------------
  任务机制以及其优先级的处理应该是贯穿整个React库的，比如单个组件渲染或者组件内部的状态变化引起组件渲染等等。

React 17共定义了18中不同优先级（lanes）来取代16版本的expirationTime，用二进制变量表示，默认为0b000000000000000000000000000000；越低优先级的lane占用的位数越多；
  是一个稳定Concurrent Model的版本；另外使用lane重构了优先级算法；事件委托也有原来的根节点document变为自定义指定的root节点，目的是为了兼容多版本共存的场景

  Reconciler将要变化的内容打上标记，如需要更新的：打上update，传入renderer时，renderer根据标记执行对应的操作；

  React Fiber（React虚拟DOM === React Fiber）可以理解为：
    React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。其中每个任务更新单元为React Element对应的Fiber节点。
    Fiber节点可以保存对应的Dom节点，Fiber节点组成的Fiber树即对应DOM树

  在内存中构建并直接替换的技术叫做双缓存，即workinprocess Fiber和current Fiber：
    fiberRoot（整个应用的根节点）和rootFiber（组件树的根节点），初始化时 fiberRoot.current = rootFiber; rootFiber.current（指向current fiber） = null;
    初次构建的fiber树赋值给workinprocess fiber（会尝试复用current fiber的fiber节点，首次渲染时current fiber为空），初次构建的fiber树构建完成commit之后，渲染时：
      rootFiber.current = workinProcess fiber
    current指针指向workinprocess fiber使其成为current fiber。以后每次更新都是先在内存中构建到workinprocess fiber，在current fiber渲染在页面之后，再重复。

---------------------------------------------------------------------
React Element 与 React Component
  0.Concurrent模式是一组react的新功能可帮助应用保持相应，并根据用户的设备性能和网速进行适当的调整。（设备性能 -> 刷新率，scheduler以及时间切片处理；网速 -> suspense以及后续hooks）
  1.jsx语法下的每一个标签在react处理的时候都会调用React.createElement方法转化为React.Element;判断是否为React.Element的方法是验证其是否是具有$$typeof属性切值等于REACT_ELEMENT_TYPE的非空Object类型对象。
  2.在组件mount时，reconciler根据jsx描述的组件内容生成fiber节点（Fiber节点组成的Fiber树即渲染为Dom树）；在组件update时，
    reconciler对比jsx描述的内容以及之前生成的fiber节点，生成组件对应的fiber节点，并打上相应的标记（placement/update/placementAndUpdate/Deletion）。

Fiber节点的创建以及Fiber树的构建
  1.render阶段有两个方法（jsx语法下React element生成Fiber节点，并由fiber节点构建fiber树的过程）;
      performSyncWorkOnRoot: 不在乎当前帧是否有剩余时间，持续遍历
      perforConcurrentWorkOnRoot: 函数实现会调用shouldYeild方法，即判断当前帧是否有剩余时间
    即一个可以中断，一个不可中断。从rootFiber开始深度优先遍历每个fiber节点（beginWork方法），递归过程中，如果某一个叶子fiber节点（即无子节点）有兄弟节点，
    则会继续遍历其兄弟节点，如无兄弟节点无子节点，则返回到其父节点，检测子节点以及兄弟节点，回归 & 重复此步骤。一直回归到rootFiber
--------------------------------------------
      备注：performUnitOfWork: 创建下一个fiber节点并赋值给workinprogress fiber, 创建其子fiber节点，形成fiber树。分为beginWork以及completeWork阶段，即“递” 与 “归”
      递归过程中，如果某一个叶子fiber节点（即无子节点）有兄弟节点，
      则会继续遍历其兄弟节点，如无兄弟节点无子节点，则返回到其父节点，检测子节点以及兄弟节点，回归 & 重复此步骤。一直回归到rootFiber
      function performUnitOfWork(fiber) {
        // 执行beginWork

        if (fiber.child) {
          performUnitOfWork(fiber.child);
        }

        // 执行completeWork

        if (fiber.sibling) {
          performUnitOfWork(fiber.sibling);
        }
      }
      
      // performSyncWorkOnRoot会调用该方法
      function workLoopSync() {
        while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
        }
      }

      // performConcurrentWorkOnRoot会调用该方法
      function workLoopConcurrent() {
        while (workInProgress !== null && !shouldYield()) {
          performUnitOfWork(workInProgress);
        }
      }


------------------------------------------------------------------------------------

HOOKS相关：

每一种操作（如，useState,useMemo,useCallback）都会维护一个hook对象，对应的更新都存储在hook.queue中吗？

1.单个组件的更新queue，更新产生的update对象会保存在queue中，会将组件每一次产生的变化update表现为一个单向循环链表： queue.pending = update1 (update1.next = update0; update0.next = update1;)
2.functionComponent更新的队列queue会被存储在对应的fiber的属性memorizedState中，所以在hook中

react在reconciler阶段，会根据节点类型不同，执行不同的操作获取节点：
  1.字符串，如"span","div"；直接使用；
  2.ReactComponnet类型（class组件），调用其render方法获取子节点；
  3.function类型（函数组件），执行该组件获取子节点。
V17.0.2定义了 20 种内部节点类型. 根据运行时环境不同, 分别采用 16 进制的字面量和Symbol进行表示。

  4.ReactComponent是 class 类型, 继承父类Component, 拥有特殊的方法(setState,forceUpdate)和特殊的属性(context,updater等)；
  5.在reconciler阶段, 会依据ReactElement对象的特征, 生成对应的 fiber 节点. 当识别到ReactElement对象是 class 类型的时候, 
    会触发ReactComponent对象的生命周期, 并调用其 render方法, 生成ReactElement子节点.
