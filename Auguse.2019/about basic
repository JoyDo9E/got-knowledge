1.设置png等格式的图片作为元素背景时， 注意一下，如果设置为：
        background: url("...") no-repeat center / cover(contain)
    那么该图片会被等比例的放大缩小，且其宽高比极可能于元素宽高比不符，会出现图片边缘被覆盖，宽、高只能满足其一的情况；解决方式为：放大图片，变center为top/bottom;
2.cross-env: 运行跨平台设置和使用环境变量的脚本; 详细见 https://www.npmjs.com/package/cross-env
3.可以用以下的方式，将build的文件以托管静态文件的方式，在浏览器中渲染出来，以检测是否存在build问题
    yarn global add serve
    serve -s dist（build后的文件夹）
4.洗牌算法：
    （1）.高纳德算法，满足每张牌出现在每个位置的概率相同即可； 5张牌5个位置，第一张：1/5；第二张：4/5*（1/4）
    function shuttle (arr) {
      if (!Array.isArray(arr)) return [];
      let res = [];
      while(arr.length){
          var r = Math.round(Math.random() * (arr.length - 1));
          res.push(arr[r]);
          arr.splice(r, 1);
      }
      return res;
    }
    （2）.模拟从牌堆里面随机（*）不放回的取牌即可实现（malloc） 随机产生index，该位置无牌则顺位后移（前移）取牌，牌组长度不变；产生的index随机数随牌组的长度变化而变化，每取一张牌，牌组长度-1
5.git相关：
    上传本地创建项目：
        git remote add origin <仓库地址>
        git push -u origin master
6.链式递加函数：
    满足：
        add(1); // 1
        add(1)(2)(3)(4); // 10
        var addTwo = add(2);
        addTwo; // 2
        addTwo + 5; // 7
    函数为：
        var add = function(n) {
          const f = x => add(n + x)
          f.valueOf = () => n
          return f;
        }
7.页面上元素的曲线运动，只是给了该元素一个随机的x方向和y方向的速度，同时使其下落速度逐渐增大（模拟重力下坠），从而形成了曲线的抛物运动；
8.DNS：域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS本地缓存则为host文件，远端DNS服务器则为分布式服务器。
9.PAC模式（proxy auto config）根据请求地址动态的设置代理地址  pac文件编辑方式：https://www.cnblogs.com/milton/p/6263596.html && http://findproxyforurl.com/pac-functions/
10.网络协议示意图：https://upload-images.jianshu.io/upload_images/11362584-157a39882f263361.png?imageMogr2/auto-orient/strip|imageView2/2/w/612/format/webp
  http/3采用udp作为传输层协议(改造成本小,兼容性处理少;google公司以udp协议为基础,开发了QUIC协议(quick udp internet connections))
  基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成[握手]和[加密协商]，完成之后才可以真正传输业务数据。
11.https协议的工作流程：https://www.cnblogs.com/anyehome/p/8858456.html
12.for...in和for...of的区别（可迭代类数组对象，且自动不遍历非自身属性，除原型属性，继承属性之外的属性）：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of
    for...in遍历的是类数组对象/对象的key值；而for...of遍历的是value
13.通过修改react-scripts来自定义create-react-app的模板; // https://www.sheng00.com/2728.html
14.css模块化：
    {
        test: /^.(sass|less|css|scss)$/,
        use: [
            'style-loader',
            {
                loader: 'css-loader',
                options: {
                    modules: true
                }
            },
            ['sass-loader', 'less-loader']
        ]
    }
15.所有的计算都可随数字的大小变化而变化，如8位二进制数无法表示，超过八位，表示为16位二进制数，1byte递增；
    计算机不做减法 只做加法
    原码：数的二进制（正数不变，负数的第一位为符号为1，如：-8， 10001000）；反码：正数不变；负数符号位不变，其他位按位取反；补码：正数不变；负数在反码的基础上加1
    如： -300 - 400
        -300，原：1000000100101100；反：1111111011010011；补：1111111011010100
        -400，原：1000000110010000；反：1111111001101111；补：1111111001110000
        结果：11111110101000100（17位，多余16位，去除第一位，1111110101000100）
16.antd骨架加载样式:
    animation: ant-skeleton-loading 1.4s ease infinite;
    background: linear-gradient(90deg, #f2f2f2 25%, #e6e6e6 37%, #f2f2f2 63%);
    background-size: 400% 100%;
    @keyframes ant-skeleton-loading{
        0% {
                background-position: 100% 50%;
            }
        100% {
            background-position: 0 50%;
        }
    }
17.箭头函数有几个使用注意点。无this,无arguments,无super/new,无prototype
   函数体内不存在this对象，故在调用时，就近访问this对象，故指向调用时的作用域；
   不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
   不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
   不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
   上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。

   箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()
   普通函数的this指向调用它的那个对象
   类中的this指向其实例；

18.react组件内部是屏蔽全局变量的。引用全局变量需要window;如引入wxsdk时，需要使用window.wx.[api]，否则会报错wx is not defined；
19.实际上，JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。如下 JSX 代码：
   <MyButton color="blue" shadowSize={2}>
     Click Me
   </MyButton>

   会编译为：

   React.createElement(
     MyButton,
     {color: 'blue', shadowSize: 2},
     'Click Me'
   )
20.定义/修改对象的属性或者方法时，可以用：
    Object.defineProperty(object: object, key: string, attributes: {enumerable: boolean, writable: boolean, configurable: boolean, value: any，(引用类型无value和wraitable属性，有set和get)})
    Object.defineProperties(obj: Object, props)
当使用字面向量法定义一个对象的某个属性的setter和getter属性时，可以简写为：
    var Example = {
        name: 'pt',
        age: undefined,
        get age () {
            return 16;
        },
        set age(age) {
            this.age = age
        }
    }
21.react中，多层传递props时（层层传递，只有最底层的组件使用改props的数据时），
    可考虑在最顶层组件处，定义一个上下文React.createContext：
        // Context lets us pass a value deep into the component tree
        // without explicitly threading it through every component.
        // Create a context for the current theme (with "light" as the default).
        const ThemeContext = React.createContext('light');

        class App extends React.Component {
          render() {
            // Use a Provider to pass the current theme to the tree below.
            // Any component can read it, no matter how deep it is.
            // In this example, we're passing "dark" as the current value.
            return (
              <ThemeContext.Provider value="dark">
                <Toolbar />
              </ThemeContext.Provider>
            );
          }
        }
    再在最底层组件处使用：
        class ThemedButton extends React.Component {
          // Assign a contextType to read the current theme context.
          // React will find the closest theme Provider above and use its value.
          // In this example, the current theme is "dark".
          static contextType = ThemeContext;
          render() {
            return <Button theme={this.context} />;
          }
        }

    综上：
    const ThemeContext = React.createContext('light');
    <ThemeContext.Provider value={theme}></ ThemeContext.Provider>  发布者  传入数据undefined
    <ThemeContext.Consumer>{theme => <Component />}</ ThemeContext.Provider>  订阅者  读取数据

22.可选链操作符（规避调用者为nullish的情况下的异常）(如调用者为nullish，返回undefined)：
    (null || undefined)?.[property]
    也可用于验证函数是否存在之后的调用：
    fn?.(arguments)

   空值合并运算符（左侧为nullish的值时，返回右侧的值）
    (null || undefined) ?? value
    与逻辑或的区别在于，逻辑或会隐式转换左侧的部分，如果左侧为（0, "", undefined, null, NaN）时，均会被转化为false，返回右侧的值；
    而空值运算符只要左侧不为undefined或null，均返回左侧的值

   逻辑空赋值运算符（左侧值为nullish时，把右侧值赋给左侧）
    (null || undefined) ??= value

23.Boolean相当于是个函数：Boolean(0); // false
  Essentially, writing:
    arr.filter(Boolean)
  is the same as writing:
    arr.filter( function(x) { return Boolean(x); }); 
  
24.React.useCallback与lodash.throttle联用时，会提示“React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead  react-hooks/exhaustive-deps”
需要改变写法：
  React.useCallback(throttle(..., 1000), [*]) ===>>> React.useMemo(() => throttle(..., 1000), [*])

25.使用react-router-dom进行跨路由跳转时（如：从/one/onesub跳转/three/threesub时），出现url变化，但是页面渲染异常的问题，解决办法：系多次使用BrowserRouter或者
HashRouter的结果（如：遍历子路由或孙路由时，再次嵌套路由组件）；去掉多层嵌套，防止路由信息丢失。


26.React.portals使用场景：某一组件，在React组件树中属于一组件的子组件（方便状态管理），但在真实Dom上属于另一元素的子元素（方便层级和展示管理）
  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。
  // `domNode` 是一个可以在任何位置的有效 DOM 节点。
  ReactDOM.createPortal(this.props.children, domNode);

27.Typescript 3.0新增unknown类型，
  任何类型都可赋值给unknown类型（即 const a: unknown = b: (number, string, boolean...)）;
  但unknown类型只能赋值给any & unknown类型的参数（即 const a: (unknown & any) = b: unknown）;
  主要用于解决  防止声明any类型的参数失去类型检查，同时可赋值任何类型 的情况：
    对 unknown 类型执行方法调用或者属性读取之类的操作，都必须先使用条件控制流或者类型断言来收窄 unknown 到指定的类型：
    // any 类型
    const doSomething = (val: any) => {
      // 没有断言，都不报错
      val();  
      val.foo.bar; 
    }

    const doSomething = (val: unknown) => {
      if (typeof val === 'function') {
        val(); // 条件分析，类型收窄到 Function，调用不报错；
      }
      // 没有断言，报错
      val.foo.bar;
      x[0];
      x();
    }

28. typescript中，数组类型，enum（枚举）类型，Tuple（元组）类型的区别：
  数组类型：number[] | Array<any> 以及 Tuple类型：a: [number, string, boolean] 都是针对数组数据进行类型声明 [备注：js弱类型语言数组中可存入任何类型的元素，元组用以声明固定位置固定类型]
  enum类型是对对象进行类型声明(并非类型声明，而是类型声明 + 赋值，可直接输出为一对象) enum x: {Up, Down, Left, Right}, 且带有自增性，即当前声明：x.Up // 0， x.Down // 1

29."在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树"

30.document.visibilityState可用于判断页面状态(>=IE 10)；"hidden" | "visibile" | "prerender"(渲染中)

31. 在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state 。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。
原因： 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。
注意： setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
详细请看 深入 setState 机制(https://github.com/sisterAn/blog/issues/26)

32.使用queueMicrotask可创建一个微任务：
    queueMicrotask(() => {//...微任务函数体})
  微任务不在其所处的函数退出时，而是在主程序退出时被执行：
    let callback = () => log("Regular timeout callback has run");
    let urgentCallback = () => log("*** Oh noes! An urgent callback has run!");
    let doWork = () => {
      let result = 1;
      queueMicrotask(urgentCallback);
      for (let i=2; i<=10; i++) {
        result *= i;
      }
      return result;
    };
    log("Main program started");
    setTimeout(callback, 0);
    log(`10! equals ${doWork()}`);
    log("Main program exiting");
    输出：
      Main program started
      10! equals 3628800
      Main program exiting
      *** Oh noes! An urgent callback has run!
      Regular timeout callback has run

33.项目中声明了alia，ts仍然报错：找不到模块“**”或其相应的类型声明。
解决：  在tsconfig.json中声明paths属性（模块名到基于 baseUrl的路径映射的列表。查看 模块解析文档了解详情。）https://www.tslang.cn/docs/handbook/compiler-options.html
        向typescript编译器解释alia，防止报错。
        如：paths: { '@': ['src'] }

34.Dom Diff图解：https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/190.%E7%B2%BE%E8%AF%BB%E3%80%8ADOM%20diff%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E3%80%8B.md

35.vue中可通过provide & inject跨层级传递 & 接收数据
  祖先组件： provide: { message: 'data' }
  后代组件： inject: ['message']

36. display: table;(父元素) & display: table-cell(子元素); vertical-align: middle 可适用于多行文本（多行行内元素）垂直居中的问题。

37.display: grid; 详解 -- 新一种多元素的栅格布局(网格布局)，比flex使用的场景更复杂
  文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout
  例子：https://codepen.io/Chokcoco/pen/jOVjxjo
  结合常用的单位：fr  repeat(n(重复次数), width)  
  以及展示边界裁剪  clip-path: https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path
  shape-outside: 定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。

38.webpack中的webpackPrefetch和webpackPreload的区别和作用：（https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules）
  1.prefetch(预获取)：将来某些导航下可能需要的资源
    import(/* webpackPrefetch: true */ './path/to/LoginModal.js');
    这会生成 <link rel="prefetch" href="login-modal-chunk.js"> 并追加到页面头部，指示着浏览器在闲置时间预取 login-modal-chunk.js 文件。
  
  2.preload(预加载)：当前导航下可能需要资源
    import(/* webpackPreload: true */ 'ChartingLibrary');
    在加载当前路由的同时，通过 <link rel="preload"> 请求 charting-library-chunk。

  3.区别：
    preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。
    preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。
    preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。
    浏览器支持程度不同。

39. webpack5配置兼容性处理polyfill，除了babelrc文件配置完毕之外，还需要设置webpack的设置target: ['web', 'es5']

40. 使用css3 counter相关，自动计数
    body {
      counter-reset: h3;
    }

    h3 {
      counter-increment: h3;
      display: list-item;
    }

    h3::marker {
      display: list-item;
      content: "✔" counter(h3) " ";
      color: lightsalmon;
      font-weight: bold;
    }

41. 浏览器中microtask & macrotask与node环境中microtask & macrotask的区别：
    https://mp.weixin.qq.com/s/E0vu7kJLcgDdJRVrAeyEIA

42. 判断元素类型的函数：
    function getType (x) {
      return Object.prototype.toString.call(x).slice(8, -1).toLowerCase();
    }

43. something >>> 0 ： 第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。

44. promise | debounce | throttle | forEach | map | filter | call | bind | apply方法手写？

45. 浏览器发起请求步骤：
  比如请求www.google.com
  1).请求地址解析（查询浏览器缓存chrome/dns；查询客户端缓存hosts；查询com；查询Google.com），查询获取结果后，缓存。（每次返回ip地址可能不一致，负载均衡）
  2).TCP三次握手建立连接，4次挥手断开连接。完成TCP链接。
  3).http数据传输，（http: 80|8080;https:443），（keep-alive的作用就是保持TCP链接不断开，随时建立http数据交互请求）

46.手写new：
  function _new (obj, ...args) {
    if (!obj) throw ('object is invalid');
    const protoObj = Object.create(obj.prototype);
    const newObj = obj.apply(protoObj, args);
    if (newObj && (typeof newObj === 'Object' || typeof newObj === 'function')) return newObj;
    return protoObj;
  }

47. 对象的constructor默认返回该对象（即this），可以使用return，但是必须返回一个对象。return了对象，则该对象实例就等于return的内容。

48. “Function Component 是更彻底的状态驱动抽象，甚至没有 Class Component 生命周期的概念，只有一个状态，而 React 负责同步到 DOM。”
    “Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。Function Component 仅描述 UI 状态，React 会将其同步到 DOM，仅此而已。”
    "诚实的代价"：(当在定时器里依赖多个参数执行叠加逻辑时，离散的useState无法满足，即每次依赖变化，都会重置定时器。必须依靠useReducer或者组合式useState。)
    const [sum, setSum] = useState(0);
    const [subSum, setSubSum] = useState(0);
    useEffect(() => {
      setInterval(() => setSum(prev => prev + subSum), 300);
    }, [subSum]);

    =====>

    const [newSum, setNewSum] = useState(() => ({
      sum: 0,
      subSum: 0
    }));
    useEffect(() => {
      setInterval(() => setNewSum(prev => ({
        ...prev,
        sum: prev.sum + prev.subSum
      })), 300);
    }, []);

    也可使用useReducer,当两state派生逻辑太复杂时，倾向使用useReducer。组合useState是useReducer的子集

  49. 监听页面关闭，强退等：
    useEffect(() => {
      const listener = (e) => {
        e.preventDefault();
        // e.returnValue = '.';
        e.returnValue = '文章要保存吼，确定离开吗？';
      };
      window.addEventListener('beforeunload', listener);
      return () => window.removeEventListener('beforeunload', listener);
    }, []);

    注意事项：
      在beforeunload事件中的confirm，prompt，alert会被忽略。取而代之的是一个浏览器内置的对话框。（参考：MDN|beforeunload）
      必须要有returnValue且为非空字符串，但是在某些浏览器中这个值并不会作为弹窗信息

  50. 实例的__proto__属性暴露的是构造函数的prototype，即：instance.__proto__ === Function.prototype
      function Person () {this.name = 'hi'};
      const p = new Person();
      p.__proto__ === Person.prototype; // true

      原型对象的constructor指向构造函数，构造函数的prototype指向原型对象
      const proto = Object.prototype
      proto.constructor === Object

  51. JSON.stringify(obj[, filterFn | filterKeyArray[, 空格数]])只会转化value值不为undefined字段

  52. 继承：构造函数部分的属性或方法为实例私有属性或方法，原型部分的属性或方法为实例公用属性或方法
      eg. function Sup () {
            this.name = 'pt'; 
            this.arr = [1, 2];
          }
          Sup.prototype.array = [3, 4];
          Sup.prototype.sayName = function () { console.log(this.arr); }
          function Sub () {}
          Sub.prototype = new Sup();
          var sub = new Sub();

          sub.arr.push(3);
          sub.array.push(5); 
          sub.sayName(); // [1, 2, 3]

          var sup = new Sup();
          sup.sayName(); // [1, 2]

  53. 各种继承方法区别和侧重点：涉及到原型则有引用类型公用的问题，涉及到构造函数则有方法私有重复创建的问题，
      涉及到组合式继承则有无法向超类传参和多次调用超类的问题；寄生式组合继承方法：原来Sub.prototype = new Sup();
      （缺点：多次执行超类函数）改为Sub.prototype = Object.create(Sup.prototype)（直接复制超类原型）。

  54. ES6的class式组件中成员属性和静态属性的区别：
      class Person {
        static today = '1019'; // 静态属性
        constructor (name) {
          this.name = name; // 成员属性
        }
      }
      静态属性是定义在类的构造函数上的，而成员属性是定义在类的实例上的。

  55. CI持续集成、CD持续交互。即线上自动化部署。

  56. Symbol相关：Symbol([description]) description: 对symbol的描述
      1).返回的symbol值都是唯一的;
      2).无法作为构造函数，即 new Symbol() // error; -> var a = Symbol('a'); var objA = Object(a);
      3).Symbol.for / Symbol.keyFor会从全局的symbol注册表中设置和取得symbol; Symbol() / Symbol.for()用于设置symbol，Symbol.keyFor用于获取Symbol的描述key；
      4).Object.getOwnPropertySymbols()用于获取symbol对象的转化而成的数组；
      5).基本属性：Symbol.length / Symbol.prototype / 

  57. 防止网站被在google上被搜索到： <meta name="googlebot" content="noindex">

  58. react-router实现原理：利用pushState和replaceState只会改变页面url而不会触发popstate事件的原理，
      通过pushState和replaceState改变页面地址，维护一个自定义的用于存储路由信息的栈，（pushState,replaceState时，
      压入或替换路由信息）监听该栈数据改变(location改变触发UI更新回调，路由匹配，找到对应组件，更新渲染)，触发组件渲染变化，
      使组件渲染，即页面渲染与当前地址对应，模拟地址切换页面渲染场景。

  59. document.createDocumentFragment可以创建一个文档碎片；类似于react的<></>，将要插入的节点统一到该碎片中，最后一次性插入dom中。

  60. Promise实现【class类中直接复制，相当于定义属性】:
    a.Promise是一个类，执行时会传入一个执行器，这个执行器立即执行；
    b.Promise有三种状态 fulfilled/rejected/pending，状态只能由pending -> fulfilled 或者 pending -> rejected；不可逆；
    c.只有resolve和reject方法能改变Promise的状态值；
    d.then方法用于通过状态判断执行对应的回调函数，fulfilled -> success / rejected -> fail
    
  // 简易版promise------------------------------------------------
    const PENDING = 'pending';
    const FULFILLED = 'fulfilled';
    const REJECTED = 'rejected';
    
    class MyPromise {
      constructor (executor) {
        executor(this.resolve, this.reject);
      }
      // 状态
      status = PENDING;
      // 结果
      result = null;
      // 失败原因
      reason = null;
      resolve = (value) => {
        if (this.status === PENDING) {
          this.status = FULFILLED;
          this.value = value;
        }
      };
      reject = (reason) => {
        if (this.status === PENDING) {
          this.status = REJECTED;
          this.reason = reason;
        }
      };
      then (onFulfilled, onReject) {
        if (this.status === FULFILLED) {
          onFulfilled(this.value);
        } else if (this.status === REJECTED) {
          onReject(this.reason);
        }
      }
    }
  // --------------------------------------------------------------

  // 简易版当exector为异步函数时，无法输出理想结果。在then函数调用之前必须改变status状态和result或者reason值
  // 进阶版
  const PENDING = 'pending';
  const FULFILLED = 'fulfilled';
  const REJECTED = 'rejected';

  // 判断一次then回调调用之后的结果是否是自定义类型
  const judgeBackInfo = (back, resolve, reject) => {
    if (back instanceof MyPromise) {
      back.then(resolve, reject);
    } else {
      resolve(back);
    }
  }

  class MyPromise {
    constructor (executor) {
      executor(this.resolve, this.reject);
    }
    // 新增成功以及失败回调函数缓存，用以在then函数执行时，状态值为pending，缓存传入的处理函数
    // onFulfilledCallback = null;
    // onRejectedCallback = null;

    // 数组形式用于保存多个then函数的调用处理
    onFulfilledCallback = [];
    onRejectedCallback = [];

    // 状态
    status = PENDING;
    // 结果
    result = null;
    // 失败原因
    reason = null;
    resolve = (value) => {
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        // this.onFulfilledCallback && this.onFulfilledCallback(this.value);
        while (this.onFulfilledCallback.length) {
          this.onFulfilledCallback.shift()(value);
        }
      }
    };
    reject = (reason) => {
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        // this.onRejectedCallback && this.onRejectedCallback(this.reason);
        while (this.onRejectedCallback.length) {
          this.onFulfilledCallback.shift()(reason);
        }
      }
    };
    then (onFulfilled, onReject) {

      // 递归调用，这样才能支持链式调用then方法
      return new MyPromise((resolve, reject) => {
        if (this.status === FULFILLED) {
          // 执行成功的情况下，支持继续执行下一then回调
          const thenRes = onFulfilled(this.value);
          judgeBackInfo(thenRes, resolve, reject);
        } else if (this.status === REJECTED) {
          onReject(this.reason);
        } else {
          // 处理单个then函数调用的情况
          // this.onFulfilledCallback = onFulfilled;
          // this.onRejectedCallback = onReject;

          /** 多个then函数调用的情况，非链式调用 */
          this.onFulfilledCallback.push(onFulfilled);
          this.onRejectedCallback.push(onReject);
        }
      })
      // if (this.status === FULFILLED) {
        // onFulfilled(this.value);
      // } else if (this.status === REJECTED) {
        // onReject(this.reason);
      // } else {
        // 处理单个then函数调用的情况
        // this.onFulfilledCallback = onFulfilled;
        // this.onRejectedCallback = onReject;

        /** 多个then函数调用的情况，非链式调用 */
        // this.onFulfilledCallback.push(onFulfilled);
        // this.onRejectedCallback.push(onReject);
      // }
    }
  }

  61. 使用以下方式设置元素的自定义css变量的值: 1. element.style.getPropertyValue('--demo-name'); 
    2.getComputedStyle(ele).getPropertyValue('--demo-name');
    3.【设置css自定义变量的值】lement.style.setProperty("--my-var", 'xxx');
  62. let style = window.getComputedStyle(element, [pseudoElt]); 通过getComputedStyle获取元素的属性；

  63. 事件循环中，定时器，异步调用只是在定时结束、请求返回后，将其对应的回调函数压入事件队列中，等待执行。（定时器不准的原因）